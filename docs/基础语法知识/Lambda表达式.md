# C++中的 Lambda 表达式

C++中的 Lambda 表达式本质上是一个匿名函数对象，是一个可以写在任意地方的匿名函数。它的核心依法结构 `[捕获列表](参数列表){函数体}`，可以被形象的拆解为 3 个部分：环境、输入、逻辑。

## [] 捕获列表（环境）

这是 Lambda 表达式区别于普通函数的最大特征，它<span style="color:#d59bf6;">定义了Lambda函数内部可以访问外部作用域中的哪些变量，以及如何访问（拷贝还是引用）</span>。

这个参数的作用是将外部变量 **“抓”** 进函数内部使用，捕获的变量会成为编译器生成的这个 **匿名类的成员变量**。

| **写法**  | **含义**                                                     |
| :-------: | ------------------------------------------------------------ |
|   `[]`    | **不捕获** 任何外部变量（仅能访问全局变量或静态变量）。       |
|   `[=]`   | **按值捕获** 外部作用域中所有可见变量（拷贝一份副本，只读）。 |
|   `[&]`   | **按引用捕获** 外部作用域中所有可见变量（类似 `T&`，操作原变量）。 |
|   `[x]`   | 仅按值捕获变量 `x`。                                         |
|  `[&x]`   | 仅按引用捕获变量 `x`。                                       |
| `[=, &y]` | 默认按值捕获，但变量 `y` 按引用捕获。                        |
| `[this]`  | 捕获当前类的 `this` 指针（在类成员函数中使用 Lambda 时常用）。 |

## ()参数列表（输入）

这和普通函数的参数列表完全一致，<span style="color:#d59bf6;">定义了调用该 Lambda 函数时需要传入的数据</span>。()里面的参数列表会在运行时传递给 Lambda 匿名函数，会传递给编译器生成的 `operator()` 函数，作为这个函数的参数。

如果这个匿名函数不需要传参，()在 C++11 中可以省略（但不推荐），C++23 后完全可选（可加可不加）；支持 auto 推导，Lambda 匿名函数的返回值可以使用 auto 自动推导。

> [!Question]
> 捕获列表和参数列表有什么区别？
>
> 捕获列表获取的变量不是调用这个Lambda函数所必须的，而是函数体内部逻辑所必须要使用的

| **特性**     | **[] 捕获列表 (Captures)**                                   | **() 参数列表 (Parameters)**                         |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| **来源**     | 来自**定义时**的上下文（环境）。                             | 来自**调用时**传入的数据。                           |
| **角色**     | 相当于类的**成员变量**（内部状态）。                         | 相当于函数的**形参**（输入数据）。                   |
| **绑定时机** | **创建时绑定**。Lambda 对象诞生那一刻，这些变量就被“装”进去了。 | **运行时绑定**。每次调用函数时，才把数据传进去。     |
| **目的**     | 携带“私货”。让函数拥有状态，或者访问它原本看不到的变量。     | 定义接口。告诉调用者：“你要用我，必须给我什么数据”。 |

## {}函数体（逻辑）

这里面写匿名函数需要执行的代码逻辑。这里面可以访问捕获的变量（来自 `[]`）和传入的参数（来自 `()`），对应编译器生成的 `operator()` 函数的具体实现代码。

## 完整语法示例

标准完整语法其实还包含 `mutable` 和 `return-type`：

[captures] (params) mutable –> return_type {body}

```c++
#include <iostream>
#include <vector>
#include <algorithm>

struct Point {
    float x, y, z;
};

void processPointCloud() {
    std::vector<Point> cloud = {{1.0, 2.0, 3.0}, {0.5, 0.5, 0.5}, {10.0, 0.0, 0.0}};
    
    // 外部变量：阈值
    float z_threshold = 1.0f; 

    // ---------------------------------------------------------
    // Lambda 表达式详解：
    // []  : [&z_threshold] -> 按引用捕获阈值，避免拷贝，且能感知外部变化
    // ()  : (const Point& p) -> 接收每一个点作为参数
    // ->  : -> bool -> 显式指定返回类型（通常编译器能自动推导，可省略）
    // {}  : 函数体 -> 判断逻辑
    // ---------------------------------------------------------
    auto filter_func = [&z_threshold](const Point& p) -> bool {
        // 可以访问 z_threshold，因为在 [] 中捕获了
        return p.z > z_threshold;
    };

    // 使用 STL 算法 count_if
    int count = std::count_if(cloud.begin(), cloud.end(), filter_func);
    
    std::cout << "Points above " << z_threshold << ": " << count << std::endl;
}

```

### `mutable` 关键字

默认情况下，按值捕获(`[=]`)的变量在 Lambda 内部是只读的（const），如果你想修改这个副本，必须加上 mutable 关键字。

```c++
int x = 10;

// 错误写法：
// auto f = [x]() { x++; }; // 编译报错：x 是 const 的

// 正确写法：
auto f = [x]() mutable { 
    x++; // 修改的是 lambda 内部拷贝的 x，不影响外部原本的 x
    std::cout << "Inside: " << x << std::endl; 
};

f(); // Inside: 11
std::cout << "Outside: " << x << std::endl; // Outside: 10
```

## 本质原理：编译器把 Lambda 变成了什么？

当编译器看到 `[a, &b](int x){ return a + b + x; }` 时，它其实在幕后生成了一个 **匿名类（Functor/仿函数）**：

```c++
// 编译器自动生成的等价类
class __Lambda_Generated_Name {
private:
    // [] 捕获列表 -> 变成了“类的私有成员变量”
    int a;      // 对应 [a] (值拷贝)
    int& b;     // 对应 [&b] (引用/指针)

public:
    // 构造函数：初始化捕获的变量
    __Lambda_Generated_Name(int _a, int& _b) : a(_a), b(_b) {}

    // () 参数列表 -> 变成了 operator() 的参数
    // {} 函数体   -> 变成了 operator() 的实现
    // 注意：默认是 const 函数，除非加了 mutable
    int operator()(int x) const {
        return a + b + x; 
    }
    // 通过重载()操作符实现匿名函数调用
};

```

1、**`[]`** $\rightarrow$ 类的**私有成员变量**（以及构造函数的初始化列表）。

2、**`()`** $\rightarrow$ 重载 **`operator()`** 的形参列表。

3、**`{}`** $\rightarrow$ 重载 **`operator()`** 的函数体。

4、**`mutable`** $\rightarrow$ 决定 `operator()` 是否是 `const` 函数。
